<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <!-- Prevent caching -->
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Relatório Gerado</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5"></script>
  <style>
    body { font-family: 'Segoe UI', sans-serif; margin:0; padding:30px; background:#fff; color:#333; }
    .hero-banner { background:#e6f2f3; padding:40px; margin-bottom:40px; }
    .hero-title { font-size:48px; color:#007c91; font-weight:600; }
    .hero-subtitle { font-size:24px; color:#007c91; font-style:italic; margin-bottom:20px; }
    .hero-meta { font-size:18px; margin-top:10px; }
    .section-title { font-size:32px; color:#337d88; margin:60px 0 20px; border-bottom:2px solid #ccc; padding-bottom:10px; }
    .chart-container { height:400px; margin-bottom:60px; }
    .turma-title { font-size:22px; font-weight:bold; margin:20px 0 10px; color:#007c91; }
    .text-question { border:1px solid #007c91; border-left:6px solid #007c91; padding:16px; margin-bottom:30px; background:#f9f9f9; }
    .text-question-title { font-weight:bold; margin-bottom:8px; font-size:16px; color:#007c91; }
    ul { padding-left:20px; }
  </style>
</head>
<body>
  <div id="reportContent"></div>

  <script>
  async function loadReport() {
    // Load filters, data, meta
    const filters = JSON.parse(localStorage.getItem('reportFilters') || localStorage.getItem('filters') || '{}');
    const [data, meta] = await Promise.all([
      fetch('https://fidalgom4t.github.io/reportfinal/data.json').then(r => r.json()),
      fetch('https://fidalgom4t.github.io/reportfinal/meta.json').then(r => r.json())
    ]);

    const container = document.getElementById('reportContent');
    container.innerHTML = '';

    // Hero banner
    const progMeta = meta.titles.find(t => t.program_id === filters.program) || {};
    const all = data.filter(d =>
      d.client === filters.client &&
      d.program === filters.program &&
      (filters.turmas||[]).includes(d.turma)
    );
    const startDate = formatMonthYear(getExtremeDate(all, 'assessment', 'min'));
    const endDate   = formatMonthYear(getExtremeDate(all, 'evaluation',  'max'));

    const hero = document.createElement('div');
    hero.className = 'hero-banner';
    hero.innerHTML = `
      <div class="hero-subtitle">${progMeta["SUBTÍTULO"]||''}</div>
      <div class="hero-title">${progMeta["TÍTULO"]||filters.program}</div>
      <div class="hero-meta"><strong>Formador:</strong> ${filters.trainer||'N/A'}</div>
      <div class="hero-meta"><strong>Scope temporal:</strong> ${startDate} – ${endDate}</div>
    `;
    container.appendChild(hero);

    // Build maps
    const labelMap = createLabelMap(meta.labels);
    const sortMap  = createSortMap(meta.labels);

    // Loop both sections
    ['assessment','evaluation'].forEach(key => {
      const sectionTitle = key==='assessment' ? 'Assessment' : 'Avaliação do Programa';

      // Section header
      const hdr = document.createElement('div');
      hdr.className = 'section-title';
      hdr.textContent = sectionTitle;
      container.appendChild(hdr);

      // Numeric-only rows
      const sectionRows = all.filter(d =>
        String(d.section||'').toLowerCase().includes(key) &&
        !isNaN(+d.value)
      );

      // Group by turma
      const byTurma = groupBy(sectionRows, 'turma');

      // Global chart if multiple turmas
      if ((filters.turmas||[]).length > 1 && sectionRows.length) {
        const globalAvg = computeAverages(sectionRows, labelMap, sortMap);
        createBarChart(`Global (${sectionTitle})`, globalAvg, container);
      }

      // Per‑turma charts
      Object.entries(byTurma).forEach(([turma, vals]) => {
        const tdiv = document.createElement('div');
        tdiv.className = 'turma-title';
        tdiv.textContent = `Turma: ${turma}`;
        container.appendChild(tdiv);

        const avgs = computeAverages(vals, labelMap, sortMap);
        createBarChart(turma, avgs, container);
      });

      // Open‑ended responses (only selected questions)
      const textRows = all.filter(d =>
        String(d.section||'').toLowerCase().includes(key) &&
        isNaN(+d.value) &&
        (filters.textQuestions||[]).includes(d.question)
      );
      renderTextQuestions(textRows, container);
    });
  }

  // Helpers

  function getExtremeDate(rows, sectionKey, mode) {
    const dates = [];
    rows.forEach(d => {
      if (String(d.section||'').toLowerCase().includes(sectionKey)) {
        const raw = d.date || d.submitted_at;
        if (raw) dates.push(new Date(raw));
      }
    });
    if (!dates.length) return null;
    return mode==='min'
      ? new Date(Math.min(...dates))
      : new Date(Math.max(...dates));
  }

  function formatMonthYear(dt) {
    if (!dt) return 'N/A';
    return dt.toLocaleDateString('pt-PT',{ month:'long', year:'numeric' });
  }

  function createLabelMap(labels) {
    const m={};
    labels.forEach(l=>{
      const q = l.questionId||l["QUESTION ID"];
      m[q] = l.label||l["LABEL"];
    });
    return m;
  }

  function createSortMap(labels) {
    const m={};
    labels.forEach(l=>{
      const q = l.questionId||l["QUESTION ID"];
      m[q] = + (l.sortOrder||l["SORT ORDER"]||l.sort_order);
    });
    return m;
  }

  function groupBy(arr, key) {
    return arr.reduce((acc,i)=>{
      (acc[i[key]] ||= []).push(i);
      return acc;
    },{});
  }

  function computeAverages(rows, labelMap, orderMap) {
    const groups={};
    rows.forEach(({question,value})=>{
      const num = +value;
      (groups[question] ||= []).push(num);
    });
    const out = Object.entries(groups).map(([q, vals])=>{
      const avgRaw = vals.reduce((a,b)=>a+b,0)/vals.length;
      return {
        question: q,
        label:    labelMap[q]||q,
        avg:      +avgRaw.toFixed(1)
      };
    });
    out.sort((a,b)=>(orderMap[a.question]||0)-(orderMap[b.question]||0));
    return out;
  }

  function createBarChart(title, data, container) {
    const div = document.createElement('div');
    div.className = 'chart-container';
    container.appendChild(div);
    echarts.init(div).setOption({
      title:{ text:title, left:'center', textStyle:{ fontSize:18 } },
      tooltip:{},
      xAxis:{ type:'category', data:data.map(d=>d.label), axisLabel:{ rotate:30 } },
      yAxis:{ type:'value', min:0, max:5 },
      series:[{
        type:'bar',
        data:data.map(d=>d.avg),
        label:{ show:true, position:'top', formatter:'{c}' },
        itemStyle:{ color(p){ const v=p.value; if(v<3)return'#d94e5d'; if(v<4)return'#f2c037'; return'#61c277'; } }
      }]
    });
  }

  function renderTextQuestions(rows, container) {
    const byQ = groupBy(rows,'question');
    Object.entries(byQ).forEach(([q, answers]) => {
      const box = document.createElement('div');
      box.className = 'text-question';
      const title = document.createElement('div');
      title.className = 'text-question-title';
      title.textContent = q;
      box.appendChild(title);
      const ul = document.createElement('ul');
      answers.forEach(a=>{
        const li = document.createElement('li');
        li.textContent = a.value;
        ul.appendChild(li);
      });
      box.appendChild(ul);
      container.appendChild(box);
    });
  }

  // Start
  loadReport();
  </script>
</body>
</html>
